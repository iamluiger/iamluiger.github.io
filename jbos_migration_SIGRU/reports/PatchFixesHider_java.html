<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <title>Source Report for PatchFixesHider.java</title>
    <link href="resources/css/bootstrap.min.css" rel="stylesheet"/>
    <link href="resources/css/font-awesome.min.css" rel="stylesheet" />
    <link href="resources/css/windup.css" rel="stylesheet" media="screen"/>
    <link rel="stylesheet" type="text/css" href="resources/libraries/snippet/jquery.snippet.min.css" />
    <link rel="stylesheet" type="text/css" href="resources/css/windup-source.css" />
    <link rel="stylesheet" type="text/css" href="resources/libraries/sausage/sausage.css" />
    <link rel="shortcut icon" href="resources/img/rhamt-icon-128.png" type="image/x-icon"/>
</head>
<body role="document" class="source-report">

    <div class="navbar navbar-default navbar-fixed-top" id="main-navbar" style="display: none">
        <div class="wu-navbar-header navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <span class="wu-navbar-header">
              <strong class="wu-navbar-header">Red Hat Application Migration Toolkit</strong>
            </span>        </div>


                <div class="navbar-collapse collapse navbar-responsive-collapse project-specific" data-project-id="21667888">
    <ul class="nav navbar-nav">
            <li class="">
                <a href="../index.html"><i class="glyphicon glyphicon-home"></i> All Applications</a>
            </li>



                <li class="">
                    <a href="report_index_SIGRU_ear.html">
                        <i class="glyphicon glyphicon-dashboard"></i>
                      Dashboard
                    </a>
                </li>


                <li class="">
                    <a href="migration_issues.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Issues
                    </a>
                </li>


                <li class="">
                    <a href="ApplicationDetails_SIGRU_ear.html">
                        <i class="glyphicon glyphicon-th-list"></i>
                      Application Details
                    </a>
                </li>


                <li class="">
                    <a href="techReport_SIGRU_ear.html">
                        <i class="fa fa-rocket"></i>
                      Technologies
                    </a>
                </li>


                <li class="">
                    <a href="dependency_graph_report.html">
                        <i class="glyphicon glyphicon-tree-deciduous"></i>
                      Dependencies Graph
                    </a>
                </li>


                <li class="">
                    <a href="Unparsable_SIGRU_ear.html">
                        <i class="glyphicon glyphicon-warning-sign"></i>
                      Unparsable
                    </a>
                </li>


                <li class="">
                    <a href="dependency_report_SIGRU_ear.html">
                        <i class="glyphicon glyphicon-retweet"></i>
                      Dependencies
                    </a>
                </li>


                <li class="">
                    <a href="remotereport_SIGRU_ear.html">
                        <i class="glyphicon service-nav-logo"></i>
                      Remote Services
                    </a>
                </li>


                <li class="">
                    <a href="tattletale_SIGRU_ear.html">
                        <i class="glyphicon tattletale-nav-logo"></i>
                      Tattletale
                    </a>
                </li>


                <li class="">
                    <a href="hardcoded_ipsSIGRU_ear.html">
                        <i class="glyphicon glyphicon-map-marker"></i>
                      Hard-coded IP Addresses
                    </a>
                </li>


                <li class="">
                    <a href="ignoredfiles_SIGRU_ear.html">
                        <i class="glyphicon glyphicon-eye-close"></i>
                      Ignored Files
                    </a>
                </li>


                <li class="">
                    <a href="about_SIGRU_ear.html">
                        <i class="fa fa-question-circle"></i>
                      About
                    </a>
                </li>
    </ul>
    <ul class="nav navbar-nav navbar-right">
<li>
    <a href="#" class="feedback-nav-btn jiraFeedbackTrigger"><i class="glyphicon glyphicon-comment"></i> Send Feedback </a>
</li>


    <script type="text/javascript" src="https://issues.jboss.org/s/f215932e68571747ac58d0f5d554396f-T/en_US-r7luaf/6346/82/1.4.16/_/download/batch/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector/com.atlassian.jira.collector.plugin.jira-issue-collector-plugin:issuecollector.js?locale=en-US&amp;collectorId=8b9e338b"></script>

    <script type="text/javascript">

    var FEEDBACK_JS_ADDED = false;
    var FEEDBACK_FORM_TRIGGER = null;

    function displayFeedbackForm() {
        FEEDBACK_FORM_TRIGGER();
    }

    window.ATL_JQ_PAGE_PROPS = {
        "triggerFunction": function(showCollectorDialog) {
            FEEDBACK_FORM_TRIGGER = showCollectorDialog;
        }
    };

    document.addEventListener("DOMContentLoaded", function(event) {
            jQuery(".jiraFeedbackTrigger").click(function(e) {
                e.preventDefault();
                displayFeedbackForm();
            });
    });
    </script>
    </ul>
                </div><!-- /.nav-collapse -->
    </div>


    <div class="container-fluid" role="main">
        <div class="row">
            <div class="page-header page-header-no-border">
                <h1>
                    <div class="main">Source Report
                    <i class="glyphicon glyphicon-info-sign" data-toggle="tooltip" data-placement=right title="This report displays what Red Hat Application Migration Toolkit found in individual files. Each item is shown below the line it was found on, and next to it, you may find a link to the rule which it was found by."></i></div>

                        <div class="path project-specific" data-project-id="21667888">
                            SIGRU.ear/SIGRU.war/WEB-INF/lib/lombok-1.18.8.jar/lombok/launch/PatchFixesHider.java
                        </div>
                </h1>
            </div>
        </div>

        <div class="row">
            <div class="container-fluid theme-showcase" role="main">

                <div class="panel panel-primary">
                    <div class="panel-heading">
                        <h3 class="panel-title">Information</h3>
                    </div>
                    <div class="panel-body" style="overflow: auto;">

                        <!--<div style="height: 120pt; float:left;"></div> Keeps the minimal height. -->
                        <div class="points" style="text-align: center; color: #00254b; padding-bottom: 1ex;">
                            <div class="number">0</div>
                            <div>Story Points</div>
                        </div>

                        <div class="info" style="margin-left: 95pt;">


                                <h4>Technologies</h4>
                                <div class="technologies" style="overflow: auto"><!-- "auto" to contain all the tags. -->
                                        <span class="label label-info" title="INFORMATIONAL">Decompiled Java File</span>
                                        <span class="label label-info" title="classloader">classloader</span>
                                </div>



                            <div style="clear: both;"/><!-- Snaps under the height keeper. Yes, the same effect could be achieved by a table. -->
                        </div><!-- .info -->
                    </div>
                </div>



                <pre id="source">
package lombok.launch;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;
import lombok.eclipse.EclipseAugments;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.IAnnotatable;
import org.eclipse.jdt.core.IAnnotation;
import org.eclipse.jdt.core.IField;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaModelException;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;
import org.eclipse.jdt.core.dom.Annotation;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.Name;
import org.eclipse.jdt.core.dom.NormalAnnotation;
import org.eclipse.jdt.core.dom.QualifiedName;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleMemberAnnotation;
import org.eclipse.jdt.core.dom.rewrite.ListRewrite;
import org.eclipse.jdt.core.search.SearchMatch;
import org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration;
import org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration;
import org.eclipse.jdt.internal.compiler.ast.Expression;
import org.eclipse.jdt.internal.compiler.ast.FieldDeclaration;
import org.eclipse.jdt.internal.compiler.ast.ForeachStatement;
import org.eclipse.jdt.internal.compiler.ast.LocalDeclaration;
import org.eclipse.jdt.internal.compiler.ast.MessageSend;
import org.eclipse.jdt.internal.compiler.lookup.BlockScope;
import org.eclipse.jdt.internal.compiler.lookup.MethodBinding;
import org.eclipse.jdt.internal.compiler.lookup.Scope;
import org.eclipse.jdt.internal.compiler.lookup.TypeBinding;
import org.eclipse.jdt.internal.compiler.parser.Parser;
import org.eclipse.jdt.internal.compiler.problem.ProblemReporter;
import org.eclipse.jdt.internal.core.SourceField;
import org.eclipse.jdt.internal.core.dom.rewrite.NodeRewriteEvent;
import org.eclipse.jdt.internal.core.dom.rewrite.RewriteEvent;
import org.eclipse.jdt.internal.core.dom.rewrite.TokenScanner;
import org.eclipse.jdt.internal.corext.refactoring.SearchResultGroup;
import org.eclipse.jdt.internal.corext.refactoring.structure.ASTNodeSearchUtil;

final class PatchFixesHider {
   public static final class Delegate {
      private static final Method HANDLE_DELEGATE_FOR_TYPE;

      static {
         Class&lt;?&gt; shadowed = PatchFixesHider.Util.shadowLoadClass(&quot;lombok.eclipse.agent.PatchDelegatePortal&quot;);
         HANDLE_DELEGATE_FOR_TYPE = PatchFixesHider.Util.findMethod(shadowed, &quot;handleDelegateForType&quot;, Object.class);
      }

      public static boolean handleDelegateForType(Object classScope) {
         return ((Boolean)PatchFixesHider.Util.invokeMethod(HANDLE_DELEGATE_FOR_TYPE, classScope)).booleanValue();
      }
   }

   public static final class ExtensionMethod {
      private static final Method RESOLVE_TYPE;
      private static final Method ERROR_NO_METHOD_FOR;
      private static final Method INVALID_METHOD;
      private static final Method INVALID_METHOD2;

      static {
         Class&lt;?&gt; shadowed = PatchFixesHider.Util.shadowLoadClass(&quot;lombok.eclipse.agent.PatchExtensionMethod&quot;);
         RESOLVE_TYPE = PatchFixesHider.Util.findMethod(shadowed, &quot;resolveType&quot;, TypeBinding.class, MessageSend.class, BlockScope.class);
         ERROR_NO_METHOD_FOR = PatchFixesHider.Util.findMethod(shadowed, &quot;errorNoMethodFor&quot;, ProblemReporter.class, MessageSend.class, TypeBinding.class, TypeBinding[].class);
         INVALID_METHOD = PatchFixesHider.Util.findMethod(shadowed, &quot;invalidMethod&quot;, ProblemReporter.class, MessageSend.class, MethodBinding.class);
         INVALID_METHOD2 = PatchFixesHider.Util.findMethod(shadowed, &quot;invalidMethod&quot;, ProblemReporter.class, MessageSend.class, MethodBinding.class, Scope.class);
      }

      public static TypeBinding resolveType(TypeBinding resolvedType, MessageSend methodCall, BlockScope scope) {
         return (TypeBinding)PatchFixesHider.Util.invokeMethod(RESOLVE_TYPE, resolvedType, methodCall, scope);
      }

      public static void errorNoMethodFor(ProblemReporter problemReporter, MessageSend messageSend, TypeBinding recType, TypeBinding[] params) {
         PatchFixesHider.Util.invokeMethod(ERROR_NO_METHOD_FOR, problemReporter, messageSend, recType, params);
      }

      public static void invalidMethod(ProblemReporter problemReporter, MessageSend messageSend, MethodBinding method) {
         PatchFixesHider.Util.invokeMethod(INVALID_METHOD, problemReporter, messageSend, method);
      }

      public static void invalidMethod(ProblemReporter problemReporter, MessageSend messageSend, MethodBinding method, Scope scope) {
         PatchFixesHider.Util.invokeMethod(INVALID_METHOD2, problemReporter, messageSend, method, scope);
      }
   }

   public static final class LombokDeps {
      public static final Method ADD_LOMBOK_NOTES;
      public static final Method POST_COMPILER_BYTES_STRING;
      public static final Method POST_COMPILER_OUTPUTSTREAM;
      public static final Method POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING;

      static {
         Class&lt;?&gt; shadowed = PatchFixesHider.Util.shadowLoadClass(&quot;lombok.eclipse.agent.PatchFixesShadowLoaded&quot;);
         ADD_LOMBOK_NOTES = PatchFixesHider.Util.findMethod(shadowed, &quot;addLombokNotesToEclipseAboutDialog&quot;, String.class, String.class);
         POST_COMPILER_BYTES_STRING = PatchFixesHider.Util.findMethod(shadowed, &quot;runPostCompiler&quot;, byte[].class, String.class);
         POST_COMPILER_OUTPUTSTREAM = PatchFixesHider.Util.findMethod(shadowed, &quot;runPostCompiler&quot;, OutputStream.class);
         POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING = PatchFixesHider.Util.findMethod(shadowed, &quot;runPostCompiler&quot;, BufferedOutputStream.class, String.class, String.class);
      }

      public static String addLombokNotesToEclipseAboutDialog(String origReturnValue, String key) {
         try {
            return (String)PatchFixesHider.Util.invokeMethod(ADD_LOMBOK_NOTES, origReturnValue, key);
         } catch (Throwable var2) {
            return origReturnValue;
         }
      }

      public static byte[] runPostCompiler(byte[] bytes, String fileName) {
         return (byte[])PatchFixesHider.Util.invokeMethod(POST_COMPILER_BYTES_STRING, bytes, fileName);
      }

      public static OutputStream runPostCompiler(OutputStream out) throws IOException {
         return (OutputStream)PatchFixesHider.Util.invokeMethod(POST_COMPILER_OUTPUTSTREAM, out);
      }

      public static BufferedOutputStream runPostCompiler(BufferedOutputStream out, String path, String name) throws IOException {
         return (BufferedOutputStream)PatchFixesHider.Util.invokeMethod(POST_COMPILER_BUFFEREDOUTPUTSTREAM_STRING_STRING, out, path, name);
      }
   }

   public static final class PatchFixes {
      public static final int ALREADY_PROCESSED_FLAG = 8388608;

      public static boolean isGenerated(ASTNode node) {
         boolean result = false;

         try {
            result = ((Boolean)node.getClass().getField(&quot;$isGenerated&quot;).get(node)).booleanValue();
            if (!result &amp;&amp; node.getParent() != null &amp;&amp; node.getParent() instanceof QualifiedName) {
               result = isGenerated(node.getParent());
            }
         } catch (Exception var2) {
            ;
         }

         return result;
      }

      public static boolean isListRewriteOnGeneratedNode(ListRewrite rewrite) {
         return isGenerated(rewrite.getParent());
      }

      public static boolean returnFalse(Object object) {
         return false;
      }

      public static boolean returnTrue(Object object) {
         return true;
      }

      public static List removeGeneratedNodes(List list) {
         try {
            List realNodes = new ArrayList(list.size());
            Iterator var3 = list.iterator();

            while(var3.hasNext()) {
               Object node = var3.next();
               if (!isGenerated((ASTNode)node)) {
                  realNodes.add(node);
               }
            }

            return realNodes;
         } catch (Exception var4) {
            return list;
         }
      }

      public static String getRealMethodDeclarationSource(String original, Object processor, MethodDeclaration declaration) throws Exception {
         if (!isGenerated(declaration)) {
            return original;
         } else {
            List&lt;Annotation&gt; annotations = new ArrayList();
            Iterator var5 = declaration.modifiers().iterator();

            while(var5.hasNext()) {
               Object modifier = var5.next();
               if (modifier instanceof Annotation) {
                  Annotation annotation = (Annotation)modifier;
                  String qualifiedAnnotationName = annotation.resolveTypeBinding().getQualifiedName();
                  if (!&quot;java.lang.Override&quot;.equals(qualifiedAnnotationName) &amp;&amp; !&quot;java.lang.SuppressWarnings&quot;.equals(qualifiedAnnotationName)) {
                     annotations.add(annotation);
                  }
               }
            }

            StringBuilder signature = new StringBuilder();
            addAnnotations(annotations, signature);
            if (((Boolean)processor.getClass().getDeclaredField(&quot;fPublic&quot;).get(processor)).booleanValue()) {
               signature.append(&quot;public &quot;);
            }

            if (((Boolean)processor.getClass().getDeclaredField(&quot;fAbstract&quot;).get(processor)).booleanValue()) {
               signature.append(&quot;abstract &quot;);
            }

            signature.append(declaration.getReturnType2().toString()).append(&quot; &quot;).append(declaration.getName().getFullyQualifiedName()).append(&quot;(&quot;);
            boolean first = true;
            Iterator var11 = declaration.parameters().iterator();

            while(var11.hasNext()) {
               Object parameter = var11.next();
               if (!first) {
                  signature.append(&quot;, &quot;);
               }

               first = false;
               signature.append(parameter);
            }

            signature.append(&quot;);&quot;);
            return signature.toString();
         }
      }

      public static void addAnnotations(List&lt;Annotation&gt; annotations, StringBuilder signature) {
         for(Iterator var3 = annotations.iterator(); var3.hasNext(); signature.append(&quot; &quot;)) {
            Annotation annotation = (Annotation)var3.next();
            List&lt;String&gt; values = new ArrayList();
            Iterator var7;
            if (annotation.isSingleMemberAnnotation()) {
               SingleMemberAnnotation smAnn = (SingleMemberAnnotation)annotation;
               values.add(smAnn.getValue().toString());
            } else if (annotation.isNormalAnnotation()) {
               NormalAnnotation normalAnn = (NormalAnnotation)annotation;
               var7 = normalAnn.values().iterator();

               while(var7.hasNext()) {
                  Object value = var7.next();
                  values.add(value.toString());
               }
            }

            signature.append(&quot;@&quot;).append(annotation.resolveTypeBinding().getQualifiedName());
            if (!values.isEmpty()) {
               signature.append(&quot;(&quot;);
               boolean first = true;
               var7 = values.iterator();

               while(var7.hasNext()) {
                  String string = (String)var7.next();
                  if (!first) {
                     signature.append(&quot;, &quot;);
                  }

                  first = false;
                  signature.append(&#39;&quot;&#39;).append(string).append(&#39;&quot;&#39;);
               }

               signature.append(&quot;)&quot;);
            }
         }

      }

      public static MethodDeclaration getRealMethodDeclarationNode(IMethod sourceMethod, CompilationUnit cuUnit) throws JavaModelException {
         MethodDeclaration methodDeclarationNode = ASTNodeSearchUtil.getMethodDeclarationNode(sourceMethod, cuUnit);
         if (isGenerated(methodDeclarationNode)) {
            IType declaringType = sourceMethod.getDeclaringType();

            Stack typeStack;
            for(typeStack = new Stack(); declaringType != null; declaringType = declaringType.getDeclaringType()) {
               typeStack.push(declaringType);
            }

            IType rootType = (IType)typeStack.pop();

            AbstractTypeDeclaration typeDeclaration;
            for(typeDeclaration = findTypeDeclaration(rootType, cuUnit.types()); !typeStack.isEmpty() &amp;&amp; typeDeclaration != null; typeDeclaration = findTypeDeclaration((IType)typeStack.pop(), typeDeclaration.bodyDeclarations())) {
               ;
            }

            if (typeStack.isEmpty() &amp;&amp; typeDeclaration != null) {
               String methodName = sourceMethod.getElementName();
               Iterator var9 = typeDeclaration.bodyDeclarations().iterator();

               while(var9.hasNext()) {
                  Object declaration = var9.next();
                  if (declaration instanceof MethodDeclaration) {
                     MethodDeclaration methodDeclaration = (MethodDeclaration)declaration;
                     if (methodDeclaration.getName().toString().equals(methodName)) {
                        return methodDeclaration;
                     }
                  }
               }
            }
         }

         return methodDeclarationNode;
      }

      public static AbstractTypeDeclaration findTypeDeclaration(IType searchType, List&lt;?&gt; nodes) {
         Iterator var3 = nodes.iterator();

         while(var3.hasNext()) {
            Object object = var3.next();
            if (object instanceof AbstractTypeDeclaration) {
               AbstractTypeDeclaration typeDeclaration = (AbstractTypeDeclaration)object;
               if (typeDeclaration.getName().toString().equals(searchType.getElementName())) {
                  return typeDeclaration;
               }
            }
         }

         return null;
      }

      public static int getSourceEndFixed(int sourceEnd, org.eclipse.jdt.internal.compiler.ast.ASTNode node) throws Exception {
         if (sourceEnd == -1) {
            org.eclipse.jdt.internal.compiler.ast.ASTNode object = (org.eclipse.jdt.internal.compiler.ast.ASTNode)node.getClass().getField(&quot;$generatedBy&quot;).get(node);
            if (object != null) {
               return object.sourceEnd;
            }
         }

         return sourceEnd;
      }

      public static int fixRetrieveStartingCatchPosition(int original, int start) {
         return original == -1 ? start : original;
      }

      public static int fixRetrieveIdentifierEndPosition(int original, int start, int end) {
         if (original == -1) {
            return end;
         } else {
            return original &lt; start ? end : original;
         }
      }

      public static int fixRetrieveEllipsisStartPosition(int original, int end) {
         return original == -1 ? end : original;
      }

      public static int fixRetrieveRightBraceOrSemiColonPosition(int original, int end) {
         return original == -1 ? end : original;
      }

      public static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, AbstractMethodDeclaration amd) {
         if (retVal == -1 &amp;&amp; amd != null) {
            boolean isGenerated = EclipseAugments.ASTNode_generatedBy.get(amd) != null;
            return isGenerated ? amd.declarationSourceEnd : -1;
         } else {
            return retVal;
         }
      }

      public static int fixRetrieveRightBraceOrSemiColonPosition(int retVal, FieldDeclaration fd) {
         if (retVal == -1 &amp;&amp; fd != null) {
            boolean isGenerated = EclipseAugments.ASTNode_generatedBy.get(fd) != null;
            return isGenerated ? fd.declarationSourceEnd : -1;
         } else {
            return retVal;
         }
      }

      public static boolean checkBit24(Object node) throws Exception {
         int bits = ((Integer)node.getClass().getField(&quot;bits&quot;).get(node)).intValue();
         return (bits &amp; 8388608) != 0;
      }

      public static boolean skipRewritingGeneratedNodes(ASTNode node) throws Exception {
         return ((Boolean)node.getClass().getField(&quot;$isGenerated&quot;).get(node)).booleanValue();
      }

      public static void setIsGeneratedFlag(ASTNode domNode, org.eclipse.jdt.internal.compiler.ast.ASTNode internalNode) throws Exception {
         if (internalNode != null &amp;&amp; domNode != null) {
            boolean isGenerated = EclipseAugments.ASTNode_generatedBy.get(internalNode) != null;
            if (isGenerated) {
               domNode.getClass().getField(&quot;$isGenerated&quot;).set(domNode, true);
            }

         }
      }

      public static void setIsGeneratedFlagForName(Name name, Object internalNode) throws Exception {
         if (internalNode instanceof org.eclipse.jdt.internal.compiler.ast.ASTNode) {
            boolean isGenerated = EclipseAugments.ASTNode_generatedBy.get((org.eclipse.jdt.internal.compiler.ast.ASTNode)internalNode) != null;
            if (isGenerated) {
               name.getClass().getField(&quot;$isGenerated&quot;).set(name, true);
            }
         }

      }

      public static RewriteEvent[] listRewriteHandleGeneratedMethods(RewriteEvent parent) {
         RewriteEvent[] children = parent.getChildren();
         List&lt;RewriteEvent&gt; newChildren = new ArrayList();
         List&lt;RewriteEvent&gt; modifiedChildren = new ArrayList();

         for(int i = 0; i &lt; children.length; ++i) {
            RewriteEvent child = children[i];
            boolean isGenerated = isGenerated((ASTNode)child.getOriginalValue());
            if (!isGenerated) {
               newChildren.add(child);
            } else {
               boolean isReplacedOrRemoved = child.getChangeKind() == 4 || child.getChangeKind() == 2;
               boolean convertingFromMethod = child.getOriginalValue() instanceof MethodDeclaration;
               if (isReplacedOrRemoved &amp;&amp; convertingFromMethod &amp;&amp; child.getNewValue() != null) {
                  modifiedChildren.add(new NodeRewriteEvent((Object)null, child.getNewValue()));
               }
            }
         }

         newChildren.addAll(modifiedChildren);
         return (RewriteEvent[])newChildren.toArray(new RewriteEvent[0]);
      }

      public static int getTokenEndOffsetFixed(TokenScanner scanner, int token, int startOffset, Object domNode) throws CoreException {
         boolean isGenerated = false;

         try {
            isGenerated = ((Boolean)domNode.getClass().getField(&quot;$isGenerated&quot;).get(domNode)).booleanValue();
         } catch (Exception var5) {
            ;
         }

         return isGenerated ? -1 : scanner.getTokenEndOffset(token, startOffset);
      }

      public static IMethod[] removeGeneratedMethods(IMethod[] methods) throws Exception {
         List&lt;IMethod&gt; result = new ArrayList();
         IMethod[] var5 = methods;
         int var4 = methods.length;

         for(int var3 = 0; var3 &lt; var4; ++var3) {
            IMethod m = var5[var3];
            if (m.getNameRange().getLength() &gt; 0 &amp;&amp; !m.getNameRange().equals(m.getSourceRange())) {
               result.add(m);
            }
         }

         return result.size() == methods.length ? methods : (IMethod[])result.toArray(new IMethod[0]);
      }

      public static SearchMatch[] removeGenerated(SearchMatch[] returnValue) {
         List&lt;SearchMatch&gt; result = new ArrayList();

         for(int j = 0; j &lt; returnValue.length; ++j) {
            SearchMatch searchResult = returnValue[j];
            if (searchResult.getElement() instanceof IField) {
               IField field = (IField)searchResult.getElement();
               IAnnotation annotation = field.getAnnotation(&quot;Generated&quot;);
               if (annotation != null) {
                  continue;
               }
            }

            result.add(searchResult);
         }

         return (SearchMatch[])result.toArray(new SearchMatch[0]);
      }

      public static SearchResultGroup[] createFakeSearchResult(SearchResultGroup[] returnValue, Object processor) throws Exception {
         if (returnValue == null || returnValue.length == 0) {
            Field declaredField = processor.getClass().getDeclaredField(&quot;fField&quot;);
            if (declaredField != null) {
               declaredField.setAccessible(true);
               SourceField fField = (SourceField)declaredField.get(processor);
               IAnnotation dataAnnotation = fField.getDeclaringType().getAnnotation(&quot;Data&quot;);
               if (dataAnnotation != null) {
                  return new SearchResultGroup[]{new SearchResultGroup((IResource)null, new SearchMatch[1])};
               }
            }
         }

         return returnValue;
      }

      public static SimpleName[] removeGeneratedSimpleNames(SimpleName[] in) throws Exception {
         Field f = SimpleName.class.getField(&quot;$isGenerated&quot;);
         int count = 0;

         for(int i = 0; i &lt; in.length; ++i) {
            if (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) {
               ++count;
            }
         }

         if (count == in.length) {
            return in;
         } else {
            SimpleName[] newSimpleNames = new SimpleName[count];
            count = 0;

            for(int i = 0; i &lt; in.length; ++i) {
               if (in[i] == null || !((Boolean)f.get(in[i])).booleanValue()) {
                  newSimpleNames[count++] = in[i];
               }
            }

            return newSimpleNames;
         }
      }

      public static org.eclipse.jdt.internal.compiler.ast.Annotation[] convertAnnotations(org.eclipse.jdt.internal.compiler.ast.Annotation[] out, IAnnotatable annotatable) {
         IAnnotation[] in;
         try {
            in = annotatable.getAnnotations();
         } catch (Exception var13) {
            return out;
         }

         if (out == null) {
            return null;
         } else {
            int toWrite = 0;

            for(int idx = 0; idx &lt; out.length; ++idx) {
               String oName = new String(out[idx].type.getLastToken());
               boolean found = false;
               IAnnotation[] var10 = in;
               int var9 = in.length;

               for(int var8 = 0; var8 &lt; var9; ++var8) {
                  IAnnotation i = var10[var8];
                  String name = i.getElementName();
                  int li = name.lastIndexOf(46);
                  if (li &gt; -1) {
                     name = name.substring(li + 1);
                  }

                  if (name.equals(oName)) {
                     found = true;
                     break;
                  }
               }

               if (!found) {
                  out[idx] = null;
               } else {
                  ++toWrite;
               }
            }

            org.eclipse.jdt.internal.compiler.ast.Annotation[] replace = out;
            if (toWrite &lt; out.length) {
               replace = new org.eclipse.jdt.internal.compiler.ast.Annotation[toWrite];
               int idx = 0;

               for(int i = 0; i &lt; out.length; ++i) {
                  if (out[i] != null) {
                     replace[idx++] = out[i];
                  }
               }
            }

            return replace;
         }
      }
   }

   public static final class Transform {
      private static final Method TRANSFORM;
      private static final Method TRANSFORM_SWAPPED;

      static {
         Class&lt;?&gt; shadowed = PatchFixesHider.Util.shadowLoadClass(&quot;lombok.eclipse.TransformEclipseAST&quot;);
         TRANSFORM = PatchFixesHider.Util.findMethod(shadowed, &quot;transform&quot;, Parser.class, CompilationUnitDeclaration.class);
         TRANSFORM_SWAPPED = PatchFixesHider.Util.findMethod(shadowed, &quot;transform_swapped&quot;, CompilationUnitDeclaration.class, Parser.class);
      }

      public static void transform(Parser parser, CompilationUnitDeclaration ast) throws IOException {
         PatchFixesHider.Util.invokeMethod(TRANSFORM, parser, ast);
      }

      public static void transform_swapped(CompilationUnitDeclaration ast, Parser parser) throws IOException {
         PatchFixesHider.Util.invokeMethod(TRANSFORM_SWAPPED, ast, parser);
      }
   }

   public static final class Util {
      private static ClassLoader shadowLoader;

      public static Class&lt;?&gt; shadowLoadClass(String name) {
         try {
            if (shadowLoader == null) {
               try {
                  Class.forName(&quot;lombok.core.LombokNode&quot;);
                  shadowLoader = PatchFixesHider.Util.class.getClassLoader();
               } catch (ClassNotFoundException var2) {
                  shadowLoader = Main.getShadowClassLoader();
               }
            }

            return Class.forName(name, true, shadowLoader);
         } catch (ClassNotFoundException var3) {
            throw sneakyThrow(var3);
         }
      }

      public static Method findMethod(Class&lt;?&gt; type, String name, Class... parameterTypes) {
         try {
            return type.getDeclaredMethod(name, parameterTypes);
         } catch (NoSuchMethodException var4) {
            throw sneakyThrow(var4);
         }
      }

      public static Object invokeMethod(Method method, Object... args) {
         try {
            return method.invoke((Object)null, args);
         } catch (IllegalAccessException var3) {
            throw sneakyThrow(var3);
         } catch (InvocationTargetException var4) {
            throw sneakyThrow(var4.getCause());
         }
      }

      private static RuntimeException sneakyThrow(Throwable t) {
         if (t == null) {
            throw new NullPointerException(&quot;t&quot;);
         } else {
            sneakyThrow0(t);
            return null;
         }
      }

      private static &lt;T extends Throwable&gt; void sneakyThrow0(Throwable t) throws T {
         throw t;
      }
   }

   public static final class Val {
      private static final Method SKIP_RESOLVE_INITIALIZER_IF_ALREADY_CALLED;
      private static final Method SKIP_RESOLVE_INITIALIZER_IF_ALREADY_CALLED2;
      private static final Method HANDLE_VAL_FOR_LOCAL_DECLARATION;
      private static final Method HANDLE_VAL_FOR_FOR_EACH;

      static {
         Class&lt;?&gt; shadowed = PatchFixesHider.Util.shadowLoadClass(&quot;lombok.eclipse.agent.PatchVal&quot;);
         SKIP_RESOLVE_INITIALIZER_IF_ALREADY_CALLED = PatchFixesHider.Util.findMethod(shadowed, &quot;skipResolveInitializerIfAlreadyCalled&quot;, Expression.class, BlockScope.class);
         SKIP_RESOLVE_INITIALIZER_IF_ALREADY_CALLED2 = PatchFixesHider.Util.findMethod(shadowed, &quot;skipResolveInitializerIfAlreadyCalled2&quot;, Expression.class, BlockScope.class, LocalDeclaration.class);
         HANDLE_VAL_FOR_LOCAL_DECLARATION = PatchFixesHider.Util.findMethod(shadowed, &quot;handleValForLocalDeclaration&quot;, LocalDeclaration.class, BlockScope.class);
         HANDLE_VAL_FOR_FOR_EACH = PatchFixesHider.Util.findMethod(shadowed, &quot;handleValForForEach&quot;, ForeachStatement.class, BlockScope.class);
      }

      public static TypeBinding skipResolveInitializerIfAlreadyCalled(Expression expr, BlockScope scope) {
         return (TypeBinding)PatchFixesHider.Util.invokeMethod(SKIP_RESOLVE_INITIALIZER_IF_ALREADY_CALLED, expr, scope);
      }

      public static TypeBinding skipResolveInitializerIfAlreadyCalled2(Expression expr, BlockScope scope, LocalDeclaration decl) {
         return (TypeBinding)PatchFixesHider.Util.invokeMethod(SKIP_RESOLVE_INITIALIZER_IF_ALREADY_CALLED2, expr, scope, decl);
      }

      public static boolean handleValForLocalDeclaration(LocalDeclaration local, BlockScope scope) {
         return ((Boolean)PatchFixesHider.Util.invokeMethod(HANDLE_VAL_FOR_LOCAL_DECLARATION, local, scope)).booleanValue();
      }

      public static boolean handleValForForEach(ForeachStatement forEach, BlockScope scope) {
         return ((Boolean)PatchFixesHider.Util.invokeMethod(HANDLE_VAL_FOR_FOR_EACH, forEach, scope)).booleanValue();
      }
   }

   public static final class ValPortal {
      private static final Method COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE;
      private static final Method COPY_INITIALIZATION_OF_LOCAL_DECLARATION;
      private static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT;
      private static final Method ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION;

      static {
         Class&lt;?&gt; shadowed = PatchFixesHider.Util.shadowLoadClass(&quot;lombok.eclipse.agent.PatchValEclipsePortal&quot;);
         COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE = PatchFixesHider.Util.findMethod(shadowed, &quot;copyInitializationOfForEachIterable&quot;, Object.class);
         COPY_INITIALIZATION_OF_LOCAL_DECLARATION = PatchFixesHider.Util.findMethod(shadowed, &quot;copyInitializationOfLocalDeclaration&quot;, Object.class);
         ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT = PatchFixesHider.Util.findMethod(shadowed, &quot;addFinalAndValAnnotationToVariableDeclarationStatement&quot;, Object.class, Object.class, Object.class);
         ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION = PatchFixesHider.Util.findMethod(shadowed, &quot;addFinalAndValAnnotationToSingleVariableDeclaration&quot;, Object.class, Object.class, Object.class);
      }

      public static void copyInitializationOfForEachIterable(Object parser) {
         PatchFixesHider.Util.invokeMethod(COPY_INITIALIZATION_OF_FOR_EACH_ITERABLE, parser);
      }

      public static void copyInitializationOfLocalDeclaration(Object parser) {
         PatchFixesHider.Util.invokeMethod(COPY_INITIALIZATION_OF_LOCAL_DECLARATION, parser);
      }

      public static void addFinalAndValAnnotationToVariableDeclarationStatement(Object converter, Object out, Object in) {
         PatchFixesHider.Util.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_VARIABLE_DECLARATION_STATEMENT, converter, out, in);
      }

      public static void addFinalAndValAnnotationToSingleVariableDeclaration(Object converter, Object out, Object in) {
         PatchFixesHider.Util.invokeMethod(ADD_FINAL_AND_VAL_ANNOTATION_TO_SINGLE_VARIABLE_DECLARATION, converter, out, in);
      }
   }
}
</pre>
            </div> <!-- /container -->
        </div><!-- /row-->
    </div><!-- /container main-->


<div style="text-align: left; font-size: small; color: gray; font-style: italic;">Page generated: 18/09/2019, 6:17:02 p.m.</div>
    <script src="resources/js/jquery-1.10.1.min.js"></script>
    <script src="resources/js/jquery-migrate-1.4.1.min.js"></script>
    <script src="resources/js/bootstrap.min.js"></script>

    <script type="text/javascript" src="resources/libraries/jquery-ui/jquery.ui.widget.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.min.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-properties.js"></script>
    <script type="text/javascript" src="resources/libraries/snippet/jquery.snippet.java-manifest.js"></script>
    <script type="text/javascript" src="resources/libraries/sausage/jquery.sausage.min.js"></script>

    <script type="text/javascript">
        var script   = document.createElement("script");
        script.type  = "text/javascript";
            script.src   = "resources/js/navbar.js";
        document.body.appendChild(script);
    </script>

    <script type="text/javascript">
        $(window).on("hashchange", function () {
            window.scrollTo(window.scrollX, window.scrollY - 50);
        });
        function offsetAnchor() {
            if(location.hash.length !== 0) {
                window.scrollTo(window.scrollX, window.scrollY - 50);
            }
        }
        window.setTimeout(function() {
            offsetAnchor();
        }, 1);
        $(document).ready(function(){
            $("pre").snippet("java",{style:"ide-eclipse", showNum:true,boxFill:"#ffeeb9", box: "593,600" });

            $("<div id='593-inlines' class='inline-source-hint-group'/>").appendTo('ol.snippet-num li:nth-child(593)');
            $("<div id='600-inlines' class='inline-source-hint-group'/>").appendTo('ol.snippet-num li:nth-child(600)');


$("<a name='50430000' class='windup-file-location'></a><div class='inline-source-comment green tag-classloader'><div class='inline-comment'><div class='inline-comment-heading'><strong class='notification info'>Dynamic class instantiation</strong><a title='View Rule: environment-dependent-calls-01000' href='windup_ruleproviders.html#environment-dependent-calls-01000'><span class='glyphicon glyphicon-link rule-link floatRight'></span></a></div><div class='inline-comment-body'><p>The class is dynamically loaded within application. During the migration, multiple classes that are provided on classpath by a different server may not be present anymore.<\/p><p>Please review the class-loading mechanisms and ensure that the dynamically loaded class is available in JBoss EAP.<\/p><ul><li><a href='https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html-single/development_guide/#class_loading_and_modules' target='_blank'>Class Loading and Modules in JBoss EAP 7</a></li><li><a href='https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6.4/html-single/Development_Guide/index.html#chap-Class_Loading_and_Modules' target='_blank'>Class Loading and Modules in JBoss EAP 6</a></li><li><a href='https://access.redhat.com/solutions/361343' target='_blank'>Article about Classloading in JBoss EAP 6</a></li></ul></div></div></div>").appendTo('#593-inlines');

$("<a name='99631112' class='windup-file-location'></a><div class='inline-source-comment green tag-classloader'><div class='inline-comment'><div class='inline-comment-heading'><strong class='notification info'>Dynamic class instantiation</strong><a title='View Rule: environment-dependent-calls-01000' href='windup_ruleproviders.html#environment-dependent-calls-01000'><span class='glyphicon glyphicon-link rule-link floatRight'></span></a></div><div class='inline-comment-body'><p>The class is dynamically loaded within application. During the migration, multiple classes that are provided on classpath by a different server may not be present anymore.<\/p><p>Please review the class-loading mechanisms and ensure that the dynamically loaded class is available in JBoss EAP.<\/p><ul><li><a href='https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6.4/html-single/Development_Guide/index.html#chap-Class_Loading_and_Modules' target='_blank'>Class Loading and Modules in JBoss EAP 6</a></li><li><a href='https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/7.0/html-single/development_guide/#class_loading_and_modules' target='_blank'>Class Loading and Modules in JBoss EAP 7</a></li><li><a href='https://access.redhat.com/solutions/361343' target='_blank'>Article about Classloading in JBoss EAP 6</a></li></ul></div></div></div>").appendTo('#600-inlines');


            $('code[class]').each(function(){
                 var codeSyntax = ($(this).attr('class'));
                 if(codeSyntax) {
                    $(this).parent().snippet(codeSyntax,{style:'ide-eclipse', menu:false, showNum:false});
                 }
            });
            $(window).sausage({ page: 'li.box' });
            $(window).resize(function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });

            $(window).load(function () {
                $('div.sausage-set').css('top', parseInt($('#main-navbar').css("height")));
            });
        });

        function qs(key) {
            key = key.replace(/[*+?^$.\[\]{}()|\\\/]/g, "\\$&"); // escape RegEx meta chars
            var match = location.search.match(new RegExp("[?&]"+key+"=([^&]+)(&|$)"));
            return match && decodeURIComponent(match[1].replace(/\+/g, " "));
        }

        $(document).ready(function() {
            var defaultProjectID = 21667888;
            var selectedProject = qs("project");
            if (!selectedProject)
                selectedProject = defaultProjectID;

            $(".project-specific").each(function(index, element) {
                var currentProject = $(element).data("project-id");

                if (currentProject == selectedProject)
                    $(element).show();
                else
                    $(element).remove();
            });
            $("#main-navbar").show();
        });
    </script>
    <script>$(document).ready(function(){$('[data-toggle="tooltip"]').tooltip();});</script>
</body>
</html>
